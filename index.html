<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>MediaPipeæ‰‹åŠ¿è¯†åˆ« - ä¼˜åŒ–ç‰ˆ</title>
    <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
    <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e7eb 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 25px;
            padding: 15px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
        }

        h1 {
            color: #007f8b;
            font-size: 1.8rem;
            margin: 10px 0;
            background: linear-gradient(90deg, #007f8b, #00b4cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: #666;
            font-size: 1rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .demo-section {
            background: white;
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            margin-bottom: 25px;
            transition: all 0.3s ease;
        }

        .demo-section:hover {
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            transform: translateY(-3px);
        }

        h2 {
            font-size: 1.4rem;
            margin: 0 0 15px;
            color: #007f8b;
            display: flex;
            align-items: center;
        }

        h2 i {
            margin-right: 10px;
            font-size: 1.6rem;
        }

        .info-text {
            color: #666;
            font-size: 1rem;
            margin: 0 0 20px;
            text-align: center;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .image-demos {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            justify-content: center;
        }

        .detectOnClick {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            aspect-ratio: 4/3;
            background: #f8f9fa;
            transition: transform 0.3s ease;
            cursor: pointer;
        }

        .detectOnClick:hover {
            transform: scale(1.02);
        }

        .detectOnClick img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .detectOnClick p {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background: rgba(0, 127, 139, 0.9);
            color: white;
            margin: 0;
            font-size: 0.9rem;
            text-align: center;
            z-index: 2;
            backdrop-filter: blur(4px);
            line-height: 1.5;
        }

        .video-demo {
            margin-top: 20px;
        }

        .videoView {
            position: relative;
            width: 100%;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            aspect-ratio: 16/9;
            background: #000;
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: rotateY(180deg);
            background: #000;
        }

        #output_canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transform: rotateY(180deg);
        }

        #gesture_output {
            display: block;
            width: 100%;
            background: linear-gradient(135deg, #007f8b 0%, #00b4cc 100%);
            color: white;
            padding: 15px;
            border-radius: 12px;
            margin-top: 15px;
            font-size: 1.1rem;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            white-space: pre-line;
            line-height: 1.6;
            box-shadow: 0 4px 12px rgba(0, 127, 139, 0.3);
        }

        .webcam-control {
            text-align: center;
            margin: 20px 0 10px;
        }

        .mdc-button {
            --mdc-typography-button-text-transform: none;
            font-weight: 600;
            border-radius: 28px;
            padding: 0 28px;
            height: 48px;
            font-size: 1.1rem;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .mdc-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        .canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
        }

        .loading-container {
            text-align: center;
            padding: 40px 30px;
            border-radius: 16px;
            background: white;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            margin: 30px 0;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            margin: 0 auto 20px;
            border: 5px solid rgba(0, 127, 139, 0.2);
            border-top: 5px solid #007f8b;
            border-radius: 50%;
            animation: spin 1.2s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 1.2rem;
            color: #007f8b;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .progress-text {
            font-size: 1rem;
            color: #666;
            margin-top: 10px;
            max-width: 500px;
            margin: 10px auto 0;
        }

        .retry-button {
            margin-top: 20px;
        }

        .error-message {
            color: #d32f2f;
            background: #ffebee;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            margin: 20px 0;
            font-size: 1rem;
            box-shadow: 0 4px 10px rgba(211, 47, 47, 0.15);
        }

        .tips {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 12px;
            margin: 20px 0;
            font-size: 0.95rem;
        }

        .tips h3 {
            color: #007f8b;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        .tips ul {
            padding-left: 20px;
        }

        .tips li {
            margin-bottom: 8px;
        }

        .mobile-warning {
            background: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 12px;
            border-radius: 0 8px 8px 0;
            margin: 15px 0;
            display: none;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.9rem;
            margin-top: 30px;
        }

        @media (max-width: 768px) {
            .image-demos {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.2rem;
            }

            .mdc-button {
                width: 100%;
                max-width: 320px;
            }

            .demo-section {
                padding: 15px;
            }

            .mobile-warning {
                display: block;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            header {
                padding: 10px;
            }

            h1 {
                font-size: 1.3rem;
            }

            .subtitle {
                font-size: 0.9rem;
            }

            .loading-container {
                padding: 30px 20px;
            }

            #gesture_output {
                font-size: 1rem;
                min-height: 80px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>MediaPipe æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ</h1>
            <p class="subtitle">ä¼˜åŒ–ç‰ˆ - è§£å†³æ¨¡å‹åŠ è½½é—®é¢˜ï¼Œæå‡ç§»åŠ¨ç«¯ä½“éªŒ</p>
        </header>

        <div class="mobile-warning">
            <strong>ç§»åŠ¨ç«¯æç¤ºï¼š</strong> é¦–æ¬¡åŠ è½½æ¨¡å‹å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´ï¼ˆçº¦15-30ç§’ï¼‰ï¼Œè¯·ä¿æŒç½‘ç»œè¿æ¥ç¨³å®šã€‚
        </div>

        <div class="tips">
            <h3>ä½¿ç”¨æç¤ºï¼š</h3>
            <ul>
                <li>ç¡®ä¿åœ¨å…‰çº¿å……è¶³çš„ç¯å¢ƒä¸‹ä½¿ç”¨ï¼Œæ‰‹åŠ¿æ¸…æ™°å¯è§</li>
                <li>å°†æ‰‹æ”¾ç½®åœ¨æ‘„åƒå¤´å‰çº¦30-50å˜ç±³å¤„</li>
                <li>å°è¯•å¸¸è§æ‰‹åŠ¿å¦‚ğŸ‘ã€âœŒï¸ã€ğŸ‘Œã€ğŸ¤™ç­‰</li>
                <li>æ¨¡å‹åŠ è½½éœ€è¦ç½‘ç»œè¿æ¥ï¼Œé¦–æ¬¡ä½¿ç”¨å¯èƒ½éœ€è¦10-30ç§’</li>
                <li>åœ¨ç§»åŠ¨ç«¯ä½¿ç”¨å»ºè®®è¿æ¥WiFiä»¥è·å¾—æ›´å¥½ä½“éªŒ</li>
            </ul>
        </div>

        <section id="demos" class="invisible">
            <div class="demo-section">
                <h2><span>ğŸ“¸</span> å›¾ç‰‡æ‰‹åŠ¿è¯†åˆ«</h2>
                <p class="info-text">ç‚¹å‡»ä¸‹æ–¹å›¾ç‰‡è¯†åˆ«æ‰‹åŠ¿ï¼Œç³»ç»Ÿå°†åˆ†ææ‰‹åŠ¿ç±»å‹å¹¶æ ‡è®°æ‰‹éƒ¨å…³é”®ç‚¹</p>

                <div class="image-demos">
                    <div class="detectOnClick">
                        <img src="https://assets.codepen.io/9177687/idea-gcbe74dc69_1920.jpg" crossorigin="anonymous"
                            title="ç‚¹å‡»è¯†åˆ«æ‰‹åŠ¿"
                            onerror="this.onerror=null;this.src='https://images.unsplash.com/photo-1512941937669-90a1b58e7e9c?auto=format&fit=crop&w=600&q=80';" />
                        <p class="classification removed"></p>
                    </div>

                    <div class="detectOnClick">
                        <img src="https://assets.codepen.io/9177687/thumbs-up-ga409ddbd6_1.png" crossorigin="anonymous"
                            title="ç‚¹å‡»è¯†åˆ«æ‰‹åŠ¿"
                            onerror="this.onerror=null;this.src='https://images.unsplash.com/photo-1580489944761-15a19d654956?auto=format&fit=crop&w=600&q=80';" />
                        <p class="classification removed"></p>
                    </div>
                </div>
            </div>

            <div class="demo-section video-demo">
                <h2><span>ğŸ¥</span> å®æ—¶æ‘„åƒå¤´æ‰‹åŠ¿è¯†åˆ«</h2>
                <p class="info-text">å¯ç”¨æ‘„åƒå¤´åï¼Œåœ¨é•œå¤´å‰åšæ‰‹åŠ¿è¿›è¡Œå®æ—¶è¯†åˆ«åˆ†æ</p>

                <div id="liveView">
                    <div class="videoView">
                        <video id="webcam" autoplay playsinline></video>
                        <canvas class="output_canvas" id="output_canvas"></canvas>
                    </div>

                    <p id='gesture_output' class="output">ç­‰å¾…æ‰‹åŠ¿è¯†åˆ«...</p>

                    <div class="webcam-control">
                        <button id="webcamButton" class="mdc-button mdc-button--raised">
                            <span class="mdc-button__ripple"></span>
                            <span class="mdc-button__label">å¯ç”¨æ‘„åƒå¤´</span>
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <div id="loading" class="loading-container">
            <div class="loading-spinner"></div>
            <div class="loading-text">æ­£åœ¨åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«ç³»ç»Ÿ</div>
            <div id="progressText" class="progress-text">åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...ï¼ˆé¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦30ç§’ï¼‰</div>
            <button id="retryButton" class="mdc-button mdc-button--outlined retry-button" style="display: none;">
                <span class="mdc-button__ripple"></span>
                <span class="mdc-button__label">é‡æ–°åŠ è½½æ¨¡å‹</span>
            </button>
        </div>

        <div id="errorContainer" style="display: none;"></div>
    </div>

    <footer>
        <p>åŸºäºMediaPipeæ‰‹åŠ¿è¯†åˆ«æŠ€æœ¯ | ä¼˜åŒ–é€‚é…ç§»åŠ¨ç«¯ | è§£å†³æ¨¡å‹åŠ è½½é—®é¢˜</p>
    </footer>

    <script type="module">
        // å¼•å…¥MediaPipeæ‰‹åŠ¿è¯†åˆ«åº“
        import {
            GestureRecognizer,
            FilesetResolver,
            DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        // DOMå…ƒç´ å¼•ç”¨
        const demosSection = document.getElementById("demos");
        const loadingElement = document.getElementById("loading");
        const progressText = document.getElementById("progressText");
        const retryButton = document.getElementById("retryButton");
        const errorContainer = document.getElementById("errorContainer");

        // å…¨å±€å˜é‡
        let gestureRecognizer;
        let runningMode = "IMAGE";
        let webcamRunning = false;
        let loadAttempts = 0;
        const MAX_RETRIES = 3;

        // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        function showError(message) {
            errorContainer.style.display = 'block';
            errorContainer.innerHTML = `
                <div class="error-message">
                    <strong>é”™è¯¯:</strong> ${message}
                    <p style="margin-top: 10px;">è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•ã€‚å¦‚æœé—®é¢˜æŒç»­å­˜åœ¨ï¼Œè¯·ç¡®ä¿æ‚¨å¯ä»¥è®¿é—®GoogleæœåŠ¡ã€‚</p>
                </div>
            `;
        }

        // æ›´æ–°åŠ è½½çŠ¶æ€
        function updateProgress(message) {
            progressText.textContent = message;
        }

        // åˆ›å»ºæ‰‹åŠ¿è¯†åˆ«å™¨ï¼ˆå¸¦å¤šCDNå›é€€æœºåˆ¶ï¼‰
        const createGestureRecognizer = async () => {
            try {
                loadAttempts++;
                updateProgress(`æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹ (å°è¯• ${loadAttempts}/${MAX_RETRIES})...`);

                // 1. å°è¯•ä»ä¸»è¦CDNåŠ è½½åŸºç¡€æ¨¡å—
                let vision;
                try {
                    vision = await FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                    );
                } catch (e) {
                    console.warn("ä¸»è¦CDNåŠ è½½å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨CDN...");
                    updateProgress("ä¸»è¦CDNåŠ è½½å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨CDN...");
                    // å°è¯•å¤‡ç”¨CDN
                    vision = await FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                    );
                }

                updateProgress('æ­£åœ¨åŠ è½½æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹...');

                // 2. å°è¯•å¤šä¸ªæ¨¡å‹æºï¼ˆå·²ä¿®å¤æ¨¡å‹åœ°å€ï¼‰
                const modelSources = [
                    "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    "https://storage.googleapis.com/mediapipe-assets/gesture_recognizer.task"  // æœ‰æ•ˆçš„å¤‡ç”¨åœ°å€
                ];

                let modelLoaded = false;

                for (let i = 0; i < modelSources.length; i++) {
                    try {
                        updateProgress(`å°è¯•ä»æº ${i + 1}/${modelSources.length} åŠ è½½æ¨¡å‹...`);
                        gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                            baseOptions: {
                                modelAssetPath: modelSources[i],
                                delegate: "GPU"
                            },
                            runningMode: runningMode
                        });
                        modelLoaded = true;
                        break;
                    } catch (modelError) {
                        console.error(`æ¨¡å‹æº ${i + 1} åŠ è½½å¤±è´¥:`, modelError);
                        if (i < modelSources.length - 1) {
                            updateProgress(`æ¨¡å‹æº ${i + 1} åŠ è½½å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª...`);
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                }

                if (!modelLoaded) {
                    throw new Error("æ‰€æœ‰æ¨¡å‹æºåŠ è½½å¤±è´¥");
                }

                // åŠ è½½å®Œæˆ
                updateProgress('åŠ è½½å®Œæˆï¼ç³»ç»Ÿå‡†å¤‡å°±ç»ª');

                // çŸ­æš‚æ˜¾ç¤ºåŠ è½½å®Œæˆ
                setTimeout(() => {
                    // éšè—åŠ è½½æç¤ºï¼Œæ˜¾ç¤ºä¸»ç•Œé¢
                    demosSection.classList.remove("invisible");
                    loadingElement.style.display = "none";
                }, 1000);

                // åˆå§‹åŒ–æŒ‰é’®
                const enableWebcamButton = document.getElementById("webcamButton");
                mdc.ripple.MDCRipple.attachTo(enableWebcamButton);

            } catch (error) {
                console.error("æ‰‹åŠ¿è¯†åˆ«å™¨åŠ è½½é”™è¯¯:", error);

                if (loadAttempts < MAX_RETRIES) {
                    updateProgress(`åŠ è½½å¤±è´¥ï¼Œå°†åœ¨3ç§’åé‡è¯• (${loadAttempts}/${MAX_RETRIES})...`);
                    setTimeout(createGestureRecognizer, 3000);
                } else {
                    updateProgress("åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥");
                    retryButton.style.display = 'block';
                    showError("æ‰‹åŠ¿è¯†åˆ«æ¨¡å‹åŠ è½½å¤±è´¥ã€‚è¯·ç¡®ä¿æ‚¨å¯ä»¥è®¿é—®GoogleæœåŠ¡æˆ–ä½¿ç”¨VPNã€‚");
                }
            }
        };

        // é‡è¯•æŒ‰é’®äº‹ä»¶
        retryButton.addEventListener('click', () => {
            retryButton.style.display = 'none';
            errorContainer.style.display = 'none';
            loadAttempts = 0;
            createGestureRecognizer();
        });

        // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«å™¨
        createGestureRecognizer();

        /********************************************************************
        // åŠŸèƒ½1: æ£€æµ‹å›¾ç‰‡ä¸­çš„æ‰‹åŠ¿
        ********************************************************************/
        const imageContainers = document.getElementsByClassName("detectOnClick");
        for (let i = 0; i < imageContainers.length; i++) {
            imageContainers[i].children[0].addEventListener("click", handleClick);
        }

        async function handleClick(event) {
            if (!gestureRecognizer) {
                alert("æ‰‹åŠ¿è¯†åˆ«å™¨å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç¨å€™");
                return;
            }

            if (runningMode === "VIDEO") {
                runningMode = "IMAGE";
                await gestureRecognizer.setOptions({ runningMode: "IMAGE" });
            }

            // æ¸…é™¤ä¹‹å‰çš„æ ‡è®°
            const allCanvas = event.target.parentNode.getElementsByClassName("canvas");
            for (let i = allCanvas.length - 1; i >= 0; i--) {
                allCanvas[i].parentNode.removeChild(allCanvas[i]);
            }

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            const p = event.target.parentNode.getElementsByClassName("classification")[0];
            p.classList.remove("removed");
            p.innerHTML = "åˆ†æä¸­...<br><div style='margin-top:5px;font-size:0.8em'>æ­£åœ¨è¯†åˆ«æ‰‹åŠ¿</div>";

            try {
                const results = gestureRecognizer.recognize(event.target);

                // æ˜¾ç¤ºç»“æœ
                if (results.gestures.length > 0) {
                    const categoryName = results.gestures[0][0].categoryName;
                    const categoryScore = parseFloat(results.gestures[0][0].score * 100).toFixed(2);
                    const handedness = results.handednesses[0][0].displayName;

                    p.innerHTML = `è¯†åˆ«ç»“æœ: ${categoryName}<br>ç½®ä¿¡åº¦: ${categoryScore}%<br>ä½¿ç”¨æ‰‹: ${handedness}`;

                    // åˆ›å»ºç”»å¸ƒç»˜åˆ¶æ‰‹éƒ¨æ ‡è®°
                    const canvas = document.createElement("canvas");
                    canvas.setAttribute("class", "canvas");
                    canvas.width = event.target.naturalWidth;
                    canvas.height = event.target.naturalHeight;
                    canvas.style.cssText = `
                        position: absolute;
                        left: 0;
                        top: 0;
                        width: 100%;
                        height: 100%;
                        pointer-events: none;
                    `;

                    event.target.parentNode.appendChild(canvas);
                    const canvasCtx = canvas.getContext("2d");
                    const drawingUtils = new DrawingUtils(canvasCtx);

                    // ç»˜åˆ¶æ‰‹éƒ¨æ ‡è®°
                    for (const landmarks of results.landmarks) {
                        drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {
                            color: "#00FF00",
                            lineWidth: 5
                        });
                        drawingUtils.drawLandmarks(landmarks, {
                            color: "#FF0000",
                            lineWidth: 1
                        });
                    }
                } else {
                    p.innerHTML = "æœªè¯†åˆ«åˆ°æ‰‹åŠ¿<br><div style='font-size:0.8em'>è¯·å°è¯•å…¶ä»–æ‰‹åŠ¿</div>";
                }
            } catch (error) {
                console.error("å›¾ç‰‡è¯†åˆ«é”™è¯¯:", error);
                p.innerHTML = "è¯†åˆ«å¤±è´¥<br><div style='font-size:0.8em'>è¯·é‡è¯•</div>";
            }
        }

        /********************************************************************
        // åŠŸèƒ½2: æ‘„åƒå¤´å®æ—¶æ‰‹åŠ¿æ£€æµ‹
        ********************************************************************/
        const video = document.getElementById("webcam");
        const canvasElement = document.getElementById("output_canvas");
        const canvasCtx = canvasElement.getContext("2d");
        const gestureOutput = document.getElementById("gesture_output");
        const webcamButton = document.getElementById("webcamButton");

        // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒæ‘„åƒå¤´
        function hasGetUserMedia() {
            return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        }

        // æ·»åŠ æ‘„åƒå¤´å¯ç”¨æŒ‰é’®äº‹ä»¶
        if (hasGetUserMedia()) {
            webcamButton.addEventListener('click', toggleWebcam);
        } else {
            console.warn("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®");
            webcamButton.disabled = true;
            webcamButton.querySelector('.mdc-button__label').textContent = "æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´";
            showError("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨Chromeã€Edgeæˆ–Firefoxç­‰ç°ä»£æµè§ˆå™¨ã€‚");
        }

        // åˆ‡æ¢æ‘„åƒå¤´çŠ¶æ€
        async function toggleWebcam() {
            if (!gestureRecognizer) {
                alert("æ‰‹åŠ¿è¯†åˆ«å™¨å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç¨å€™");
                return;
            }

            if (webcamRunning) {
                // å…³é—­æ‘„åƒå¤´
                stopWebcam();
                webcamButton.querySelector('.mdc-button__label').textContent = "å¯ç”¨æ‘„åƒå¤´";
                gestureOutput.textContent = "æ‘„åƒå¤´å·²å…³é—­";
            } else {
                // å¯ç”¨æ‘„åƒå¤´
                try {
                    webcamButton.querySelector('.mdc-button__label').textContent = "æ­£åœ¨å¯åŠ¨...";
                    await startWebcam();
                    webcamButton.querySelector('.mdc-button__label').textContent = "å…³é—­æ‘„åƒå¤´";
                } catch (error) {
                    console.error("æ‘„åƒå¤´å¯ç”¨å¤±è´¥:", error);
                    showError(`æ‘„åƒå¤´å¯ç”¨å¤±è´¥: ${error.message}`);
                    webcamButton.querySelector('.mdc-button__label').textContent = "å¯ç”¨æ‘„åƒå¤´";
                }
            }
        }

        // å¯åŠ¨æ‘„åƒå¤´
        async function startWebcam() {
            try {
                // è¯·æ±‚æ‘„åƒå¤´è®¿é—®æƒé™
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                video.srcObject = stream;

                // ç­‰å¾…è§†é¢‘æ•°æ®åŠ è½½
                await new Promise((resolve) => {
                    video.onloadeddata = resolve;
                });

                // è®¾ç½®canvaså°ºå¯¸ä¸è§†é¢‘ä¸€è‡´
                canvasElement.width = video.videoWidth;
                canvasElement.height = video.videoHeight;

                // å¼€å§‹é¢„æµ‹
                webcamRunning = true;
                predictWebcam();
            } catch (err) {
                console.error("æ‘„åƒå¤´è®¿é—®é”™è¯¯:", err);
                if (err.name === 'NotAllowedError') {
                    showError("æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»ã€‚è¯·æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®å¹¶å…è®¸è®¿é—®æ‘„åƒå¤´ã€‚");
                } else if (err.name === 'NotFoundError') {
                    showError("æœªæ‰¾åˆ°å¯ç”¨çš„æ‘„åƒå¤´è®¾å¤‡ã€‚");
                } else if (err.name === 'NotReadableError') {
                    showError("æ‘„åƒå¤´è®¾å¤‡å·²è¢«å ç”¨ï¼Œè¯·å…³é—­å…¶ä»–ä½¿ç”¨æ‘„åƒå¤´çš„åº”ç”¨ã€‚");
                } else {
                    showError(`æ— æ³•è®¿é—®æ‘„åƒå¤´: ${err.message}`);
                }
                throw err;
            }
        }

        // åœæ­¢æ‘„åƒå¤´
        function stopWebcam() {
            webcamRunning = false;
            if (video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }

            // æ¸…é™¤ç”»å¸ƒ
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        }

        let lastVideoTime = -1;
        let results = undefined;

        // å®æ—¶æ‰‹åŠ¿è¯†åˆ«é¢„æµ‹
        async function predictWebcam() {
            if (!webcamRunning) return;

            try {
                // ç¡®ä¿æ‰‹åŠ¿è¯†åˆ«å™¨è®¾ç½®ä¸ºè§†é¢‘æ¨¡å¼
                if (runningMode === "IMAGE") {
                    runningMode = "VIDEO";
                    await gestureRecognizer.setOptions({ runningMode: "VIDEO" });
                }

                // è·å–å½“å‰æ—¶é—´æˆ³
                let nowInMs = Date.now();

                // ä»…å½“è§†é¢‘å¸§æ›´æ–°æ—¶è¿›è¡Œè¯†åˆ«
                if (video.currentTime !== lastVideoTime) {
                    lastVideoTime = video.currentTime;
                    results = gestureRecognizer.recognizeForVideo(video, nowInMs);
                }

                // æ¸…é™¤ç”»å¸ƒ
                canvasCtx.save();
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                const drawingUtils = new DrawingUtils(canvasCtx);

                // ç»˜åˆ¶æ£€æµ‹ç»“æœ
                if (results && results.landmarks) {
                    for (const landmarks of results.landmarks) {
                        drawingUtils.drawConnectors(landmarks, GestureRecognizer.HAND_CONNECTIONS, {
                            color: "#00FF00",
                            lineWidth: 5
                        });
                        drawingUtils.drawLandmarks(landmarks, {
                            color: "#FF0000",
                            lineWidth: 2
                        });
                    }
                }
                canvasCtx.restore();

                // æ˜¾ç¤ºæ‰‹åŠ¿è¯†åˆ«ç»“æœ
                if (results && results.gestures && results.gestures.length > 0) {
                    const categoryName = results.gestures[0][0].categoryName;
                    const categoryScore = parseFloat(results.gestures[0][0].score * 100).toFixed(2);
                    const handedness = results.handednesses[0][0].displayName;
                    gestureOutput.innerHTML = `è¯†åˆ«ç»“æœ: <strong>${categoryName}</strong><br>ç½®ä¿¡åº¦: ${categoryScore}%<br>ä½¿ç”¨æ‰‹: ${handedness}`;
                } else {
                    gestureOutput.innerHTML = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿<br><small>è¯·å°†æ‰‹æ”¾åœ¨æ‘„åƒå¤´å‰</small>";
                }
            } catch (error) {
                console.error("æ‰‹åŠ¿è¯†åˆ«é”™è¯¯:", error);
                if (webcamRunning) {
                    gestureOutput.innerHTML = "è¯†åˆ«å‡ºé”™<br><small>è¯·é‡è¯•</small>";
                }
            }

            // ç»§ç»­é¢„æµ‹
            if (webcamRunning) {
                window.requestAnimationFrame(predictWebcam);
            }
        }
    </script>
</body>

</html>